<!DOCTYPE html>
<html>
<head>
	<title>EX</title>
	<meta charset="UTF-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
	<meta content="yes" name="apple-mobile-web-app-capable" />
	<meta content="black" name="apple-mobile-web-app-status-bar-style" />
	<meta content="telephone=no" name="format-detection" />
	
	
    <link rel="icon" href="/favicon.ico">
  	
  	<link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
<div class="author-meta">
	<div class="site-title">
		<h1><a href="http://www.startexample.com">EX</a></h1>
		<h3>
			<span>生活因折腾而精彩</span>
			<span class="site-title-offset">技术因专注而精进</span>
		</h3>
	</div>
	<div class="site-popularize">
		<div><span>Email: </span>1273203953@qq.com</div>
		<div><span>Location: </span>杭州·浙江</div>
		<div><span>GitHub: </span><a target="_blank" href="https://github.com/ncuzp">https://github.com/ncuzp</a></div>
	</div>
</div>
<div class="translate">
	<span class="show-text"></span>
	<input type="button" value="Trans" class="translate-btn" />
</div>
<div class="post">
	<div class="post-head">
		



	</div>
	<div class="markdown-text">
		<p>原文链接: <a href="http://nedbatchelder.com/text/assert.html" target="_blank" rel="external">Asserts</a></p>
<h2 id="断言失败时的几种处理方式-1-整个程序停止运行以防止脏数据的产生-2-对正在运行对程序抛出异常而不会影响整个运用-3-把断言失败信息记录下来并继续运行-4-调试模式下弹出提示框供选择-注意断言自身产生的BUG和陷阱"><a href="#断言失败时的几种处理方式-1-整个程序停止运行以防止脏数据的产生-2-对正在运行对程序抛出异常而不会影响整个运用-3-把断言失败信息记录下来并继续运行-4-调试模式下弹出提示框供选择-注意断言自身产生的BUG和陷阱" class="headerlink" title="断言失败时的几种处理方式:1. 整个程序停止运行以防止脏数据的产生. 2. 对正在运行对程序抛出异常而不会影响整个运用. 3. 把断言失败信息记录下来并继续运行. 4. 调试模式下弹出提示框供选择. 注意断言自身产生的BUG和陷阱!"></a><code>断言失败时的几种处理方式:1. 整个程序停止运行以防止脏数据的产生. 2. 对正在运行对程序抛出异常而不会影响整个运用. 3. 把断言失败信息记录下来并继续运行. 4. 调试模式下弹出提示框供选择. 注意断言自身产生的BUG和陷阱!</code></h2><p>Asserts are a valuable tool for testing code. They allow you to verify your understanding of the system you are building. A condition that must be true (an assertion) is tested to see if it is true.</p>
<h1 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h1><p>In keeping with the importance of well-defined interfaces, I’m going to separate the caller’s view of an assert (its semantics) from its behavior.</p>
<p>The assert facility takes the form of a function call with one argument. (Whether it is actually a function, a macro, or a built-in depends on the language and the implementation). The argument is a condition (an expression) which must be true, for example:</p>
<p><code>ASSERT(pFoo != NULL);</code></p>
<p>Here is the formal definition of the ASSERT(expr) interface:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASSERT(expr)&#10;Asserts that an expression is true. The expression may or may not be evaluated.&#10;&#10;If the expression is true, execution continues normally.&#10;If the expression is false, what happens is undefined.</span><br></pre></td></tr></table></figure>
<p>The false case is the important one: if the condition is false, all bets are off. There are two reasons for this. One, if the expression was never evaluated, then execution will continue even if the expression is false. Two, how a false assertion should be handled is really a question of the overall behavior of the system, not something the programmer can decide (or count on) where the ASSERT was used.</p>
<p>It is also important to remember that the expression may not be tested at all. It is common for asserts to be removed completely in non-debug builds, so that they add no overhead to the final product.</p>
<p>A note on terminology: the condition (or expression) being tested is the assertion. If the condition is tested and found to be false, that is a failed assertion, although colloquially, people often say the system “has asserted”. The phrase “raise an assertion” is also used, paralleling “raise an exception”.</p>
<h1 id="Behavior"><a href="#Behavior" class="headerlink" title="Behavior"></a>Behavior</h1><p>So what should happen if the asserted condition is false? Once the semantics are defined as they are above, the behavior can be chosen based on the system as a whole. There are a number of choices:</p>
<ul>
<li><code>Stop abruptly.</code> Crash the process, or set a global flag that prevents anything else from happening, or call exit(). Ironically, this is chosen when reliability it the most important concern. The reason is that once an assert is false, there’s no telling what other assumptions are incorrect. There’s no way to predict what the system will do. Stopping abruptly will prevent the software from doing bad things (like corrupting user data).</li>
<li><code>Throw an exception.</code> If you’ve used exception handling throughout your application, throwing an exception could be a reasonable choice. The current activity will stop, but the overall progress of the application will be unimpeded.</li>
<li><code>Print a message and keep on going.</code> This doesn’t seem like a good choice, but if you want to try continuing, and don’t have an exception infrastructure (why don’t you?), this may be your best option.</li>
<li><code>Present the developer with a dialog of choices.</code> In a debugging environment, the best choice is to defer to the developer. Put up a dialog that lets the developer choose the course of action. Windows developers are familiar with the Abort/Retry/Ignore box where Retry means Debug.</li>
</ul>
<p>Once you’ve chosen a behavior for ASSERT, don’t confuse the semantics with the behavior. The semantics remain the same: condition may be tested, true condition continues normally, false condition is undefined.</p>
<h1 id="Traps"><a href="#Traps" class="headerlink" title="Traps"></a>Traps</h1><p>Of course, asserts are not without their pitfalls. For example, if the asserted expression has side-effects, you can end up with baffling bugs when the asserts are compiled away. This is bad:</p>
<p><code>ASSERT(SetImportantValue(3) == true);</code></p>
<p>Some environments (for example, Microsoft’s MFC) accommodate the impulse to write these asserts by providing another macro with the same semantics as ASSERT, except that the expression is guaranteed to be evaluated:</p>
<p><code>VERIFY(SetImportantValue(3) == true);</code></p>
<p>Another trap is that each assert is one more line of code which itself could have bugs. Consider this (real) example:</p>
<p><code>ASSERT(pFoo = NULL);</code></p>
<p>Not only does the assert not do what it was supposed to do (check that pFoo is NULL), but it accidentally fixes the problem it was meant to detect. If pFoo is wrong (not NULL), this assert will set it to NULL, obscuring the problem. If the ASSERT is compiled away in a release build, the code will start working worse than it did in the debug build.</p>
<h1 id="When-not-to-use-asserts"><a href="#When-not-to-use-asserts" class="headerlink" title="When not to use asserts"></a>When not to use asserts</h1><p>Asserts should be used only where it is “impossible” for the condition to be false. Don’t use them to:</p>
<ul>
<li>Test input from the user.</li>
<li>Check the validity of on-disk structures.</li>
<li>Test that your compiler is working properly (because if it isn’t, the assert mechanism itself is called into question).</li>
</ul>

	</div>
</div>
<script src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js" type="text/javascript"></script>
<script src="/js/translate.js" type="text/javascript"></script>

<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-76506889-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>