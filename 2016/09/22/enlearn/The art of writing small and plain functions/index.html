<!DOCTYPE html>
<html>
<head>
	<title>Hardog&#39;s blog</title>
	<meta charset="UTF-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
	<meta content="yes" name="apple-mobile-web-app-capable" />
	<meta content="black" name="apple-mobile-web-app-status-bar-style" />
	<meta content="telephone=no" name="format-detection" />
	
	
    <link rel="icon" href="/favicon.ico">
  	
  	<link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
<div class="author-meta">
	<div class="site-title">
		<h1><a href="http://hardog.net">Hardog&#39;s blog</a></h1>
		<h3>
			<span>trace forever</span>
		</h3>
	</div>
	<div class="site-popularize">
		<div><span>Group: </span>572218159</div>
		<div><span>Email: </span>1273203953@qq.com</div>
		<div><span>Location: </span>hangzhou·zhejiang</div>
		<div><span>GitHub: </span><a target="_blank" href="https://github.com/hardog">https://github.com/hardog</a></div>
	</div>
</div>
<div class="translate">
	<span class="show-text"></span>
	<input type="button" value="Trans" class="translate-btn" />
</div>
<div class="post">
	<div class="post-head">
		

<article class="article">
		<h3> <a href="http://hardog.net/2016/09/22/enlearn/The art of writing small and plain functions/">The art of writing small and plain functions</a> </h3>
		<aside class="article-meta">
			<span>时间: 2016-09-22 09:07:40 </span>
			<span class="article-tag">
			标签:
			
				
				<a href="/tags/english/">english</a>
			
			</span>
		</aside>
</article>



	</div>
	<div class="markdown-text">
		<p>原文链接: <a href="https://rainsoft.io/the-art-of-writing-small-and-plain-functions/?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=ios" target="_blank" rel="external">The art of writing small and plain functions</a></p>
<p>The complexity of software applications is growing. The code quality is important in order to make the application stable and easily extensible.
<code>软件应用正变的越来越复杂. 要想使得应用变的稳定和易扩展, 代码质量起到至关重要的作用.</code></p>
<p>Unfortunately almost every developer, including myself, in his career faced with bad quality code. And it's a swamp.
Such code has the following harmful characteristics:
<code>不幸的是, 包括我自己在内几乎所有的软件开发者在他的职业生涯中都遇到过质量差的代码, 它带给我们很多的麻烦. 质量差的代码大致有如下几个特点:</code></p>
<ul>
<li>Functions are too long and do too many things</li>
<li>Often functions have side effects that are difficult to understand or even debug</li>
<li>Unclear naming of functions and variables</li>
<li>Fragile code: a small modification unexpectedly breaks other application components</li>
<li>Poor or missing code coverage</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. &#19968;&#20010;&#20989;&#25968;&#32844;&#36131;&#22826;&#22810;, &#20989;&#25968;&#20307;&#24456;&#38271;.&#10;2. &#36825;&#26679;&#30340;&#20989;&#25968;&#26377;&#24456;&#22823;&#30340;&#21103;&#20316;&#29992;&#23548;&#33268;&#24456;&#38590;&#29702;&#35299;&#21644;&#35843;&#35797;.&#10;3. &#21547;&#31946;&#19981;&#28165;&#30340;&#20989;&#25968;&#21644;&#21464;&#37327;&#21629;&#21517;.&#10;4. &#19981;&#20581;&#22766;&#20195;&#30721;, &#23567;&#23567;&#30340;&#20462;&#25913;&#23601;&#21487;&#33021;&#23548;&#33268;&#31243;&#24207;&#20869;&#20854;&#20182;&#21151;&#33021;&#26080;&#27861;&#27491;&#24120;&#24037;&#20316;.&#10;5. &#32570;&#23569;&#25110;&#32773;&#27809;&#26377;&#20195;&#30721;&#35206;&#30422;&#29575;&#27979;&#35797;.</span><br></pre></td></tr></table></figure></p>
<p>It sounds very common: &quot;I don't understand how this code works&quot;, &quot;this code is a mess&quot;, &quot;it's hard to modify this code&quot; and the like.</p>
<p>Once I had a situation when my colleague quit his job because he dealt with a REST API on Ruby that was hard to maintain. He received this project from previous team of developers.
Fixing current bugs creates new ones, adding new features creates a new series of bugs and so on (fragile code). The client didn't want to rebuild the application with a better design, and the developer made the correct decision to quit.</p>
<p><img src="/images/post/20160922/mac-sick.jpg" alt="mac-sick"></p>
<p>Ok, such situations happen often and are sad. But what do to?</p>
<p>The first to keep in mind: simply making the application run and taking care of the code quality are different tasks.
On one side you implement the app requirements. But on the other side you should take time to verify if any function doesn't have too much responsibility, write comprehensive variable and function names, avoid functions with side effects and so on.</p>
<p>The functions (including object methods) are the little gears that make the application run. First you should concentrate on their structure and composition. The current article covers best practices how to write plain, understandable and easy to test functions.</p>
<h1>1. Functions should be small. Really small</h1>
<p>Big functions that have a lot of responsibility should be avoided and split into small ones. Big black box functions are difficult to understand, modify and especially test.</p>
<p>Suppose a scenario when a function should return the weight of an array, map or plain JavaScript object. The weight is calculated by summing the property values:</p>
<ul>
<li>1 point for null or undefined</li>
<li>2 points for a primitive type</li>
<li>4 points for an object or function.</li>
</ul>
<p>For example the weight of an array [null, 'Hello World', {}] is calculated this way: 1 (for null) + 2 (for string primitive type) + 4 (for an object) = 7.</p>
<h1>Step 0: The initial big function</h1>
<p>Let's start with the worst practice. The logic is coded within a single big function getCollectionWeight():</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getCollectionWeight(collection) &#123;  &#10;  let collectionValues;&#10;  if (collection instanceof Array) &#123;&#10;    collectionValues = collection;&#10;  &#125; else if (collection instanceof Map) &#123;&#10;    collectionValues = [...collection.values()];&#10;  &#125; else &#123;&#10;    collectionValues = Object.keys(collection).map(function (key) &#123;&#10;      return collection[key];&#10;    &#125;);&#10;  &#125;&#10;  return collectionValues.reduce(function(sum, item) &#123;&#10;    if (item == null) &#123;&#10;      return sum + 1;&#10;    &#125; &#10;    if (typeof item === &#39;object&#39; || typeof item === &#39;function&#39;) &#123;&#10;      return sum + 4;&#10;    &#125;&#10;    return sum + 2;&#10;  &#125;, 0);&#10;&#125;&#10;let myArray = [null, &#123; &#125;, 15];  &#10;let myMap = new Map([ [&#39;functionKey&#39;, function() &#123;&#125;] ]);  &#10;let myObject = &#123; &#39;stringKey&#39;: &#39;Hello world&#39; &#125;;  &#10;getCollectionWeight(myArray);  // =&#62; 7 (1 + 4 + 2)  &#10;getCollectionWeight(myMap);    // =&#62; 4  &#10;getCollectionWeight(myObject); // =&#62; 2</span><br></pre></td></tr></table></figure></p>
<p>The problem is clearly visible. getCollectionWeight() function is too big and looks like a black box full of surprises.
You probably find it difficult to understand what it does from the first sight. And imagine a bunch of such functions in an application.</p>
<p>When you work with such code, you waste time and effort. On the other side the quality code doesn't make you feel uncomfortable. Quality code with small and self-explanatory functions is a pleasure to read and easy to follow.</p>
<p><img src="/images/post/20160922/1.png" alt="1"></p>
<h1>Step 1: Extract weight by type and drop magic numbers</h1>
<p>Now the goal is to split the big function into smaller, independent and reusable ones. The first step is to extract the code that determines the weight of a value by its type. This new function will be named getWeight().</p>
<p>Also take a look at the magic weight numbers: 1, 2 and 4. Simply reading these numbers without knowing the whole story does not provide useful information. Fortunately ES2015 allows to declare const read-only references, so you can easily create constants with meaningful names to knockout the magic numbers.</p>
<p>Let's create the small function getWeightByType() and improve getCollectionWeight() accordingly:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Code extracted into getWeightByType()&#10;function getWeightByType(value) &#123;  &#10;  const WEIGHT_NULL_UNDEFINED  = 1;&#10;  const WEIGHT_PRIMITIVE       = 2;&#10;  const WEIGHT_OBJECT_FUNCTION = 4;&#10;  if (value == null) &#123;&#10;    return WEIGHT_NULL_UNDEFINED;&#10;  &#125; &#10;  if (typeof value === &#39;object&#39; || typeof value === &#39;function&#39;) &#123;&#10;    return WEIGHT_OBJECT_FUNCTION;&#10;  &#125;&#10;  return WEIGHT_PRIMITIVE;&#10;&#125;&#10;function getCollectionWeight(collection) &#123;  &#10;  let collectionValues;&#10;  if (collection instanceof Array) &#123;&#10;    collectionValues = collection;&#10;  &#125; else if (collection instanceof Map) &#123;&#10;    collectionValues = [...collection.values()];&#10;  &#125; else &#123;&#10;    collectionValues = Object.keys(collection).map(function (key) &#123;&#10;      return collection[key];&#10;    &#125;);&#10;  &#125;&#10;  return collectionValues.reduce(function(sum, item) &#123;&#10;    return sum + getWeightByType(item);&#10;  &#125;, 0);&#10;&#125;&#10;let myArray = [null, &#123; &#125;, 15];  &#10;let myMap = new Map([ [&#39;functionKey&#39;, function() &#123;&#125;] ]);  &#10;let myObject = &#123; &#39;stringKey&#39;: &#39;Hello world&#39; &#125;;  &#10;getCollectionWeight(myArray);  // =&#62; 7 (1 + 4 + 2)  &#10;getCollectionWeight(myMap);    // =&#62; 4  &#10;getCollectionWeight(myObject); // =&#62; 2</span><br></pre></td></tr></table></figure></p>
<p>Looks better, right?
getWeightByType() function is an independent component that simply determines the weight by type. And reusable, as you can execute it in any other function.</p>
<p>getCollectionWeight() becomes a bit lighter.</p>
<p>WEIGHT_NULL_UNDEFINED, WEIGHT_PRIMITIVE and WEIGHT_OBJECT_FUNCTION are self-explanatory constants that describe the type weights. You don't have to guess what 1, 2 and 4 numbers mean.</p>
<h1>Step 2: Continue splitting and make it extensible</h1>
<p>However the updated version still has drawbacks.
Imagine that you have the plan to implement the weight evaluation of a Set or even other custom collection. getCollectionWeight() will grow fast in size, because it contains the logic of collecting the values.</p>
<p>Let's extract into separated functions the code that gathers values from maps getMapValues() and plain JavaScript objects getPlainObjectValues(). Take a look at the improved version:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getWeightByType(value) &#123;  &#10;  const WEIGHT_NULL_UNDEFINED = 1;&#10;  const WEIGHT_PRIMITIVE = 2;&#10;  const WEIGHT_OBJECT_FUNCTION = 4;&#10;  if (value == null) &#123;&#10;    return WEIGHT_NULL_UNDEFINED;&#10;  &#125; &#10;  if (typeof value === &#39;object&#39; || typeof value === &#39;function&#39;) &#123;&#10;    return WEIGHT_OBJECT_FUNCTION;&#10;  &#125;&#10;  return WEIGHT_PRIMITIVE;&#10;&#125;&#10;// Code extracted into getMapValues()&#10;function getMapValues(map) &#123;  &#10;  return [...map.values()];&#10;&#125;&#10;// Code extracted into getPlainObjectValues()&#10;function getPlainObjectValues(object) &#123;  &#10;  return Object.keys(object).map(function (key) &#123;&#10;    return object[key];&#10;  &#125;);&#10;&#125;&#10;function getCollectionWeight(collection) &#123;  &#10;  let collectionValues;&#10;  if (collection instanceof Array) &#123;&#10;    collectionValues = collection;&#10;  &#125; else if (collection instanceof Map) &#123;&#10;    collectionValues = getMapValues(collection);&#10;  &#125; else &#123;&#10;    collectionValues = getPlainObjectValues(collection);&#10;  &#125;&#10;  return collectionValues.reduce(function(sum, item) &#123;&#10;    return sum + getWeightByType(item);&#10;  &#125;, 0);&#10;&#125;&#10;let myArray = [null, &#123; &#125;, 15];  &#10;let myMap = new Map([ [&#39;functionKey&#39;, function() &#123;&#125;] ]);  &#10;let myObject = &#123; &#39;stringKey&#39;: &#39;Hello world&#39; &#125;;  &#10;getCollectionWeight(myArray);  // =&#62; 7 (1 + 4 + 2)  &#10;getCollectionWeight(myMap);    // =&#62; 4  &#10;getCollectionWeight(myObject); // =&#62; 2</span><br></pre></td></tr></table></figure></p>
<p>If you read getCollectionWeight() now, you find much easier figure out what it does. It looks like an interesting story.</p>
<p>Every function is obvious and straightforward. You don't waste time digging to realize what the code does. That's how the clean code should be.</p>
<h1>Step 3: Never stop to improve</h1>
<p>Even at this step you have a lot of space for improvement!</p>
<p>You can create getCollectionValues() as a separated function, which contains the if/else statements to differentiate the collection types:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getCollectionValues(collection) &#123;  &#10;  if (collection instanceof Array) &#123;&#10;    return collection;&#10;  &#125;&#10;  if (collection instanceof Map) &#123;&#10;    return getMapValues(collection);&#10;  &#125;&#10;  return getPlainObjectValues(collection);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Then getCollectionWeight() would become truly plain, because the only thing it needs to do is: get the collection values getCollectionValues() and apply the sum reducer on it.</p>
<p>You can also create a separated reducer function:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function reduceWeightSum(sum, item) &#123;  &#10;  return sum + getWeightByType(item);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Because ideally getCollectionWeight() should not define functions.</p>
<p>In the end the initial big function is transformed into the following small functions:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getWeightByType(value) &#123;  &#10;  const WEIGHT_NULL_UNDEFINED = 1;&#10;  const WEIGHT_PRIMITIVE = 2;&#10;  const WEIGHT_OBJECT_FUNCTION = 4;&#10;  if (value == null) &#123;&#10;    return WEIGHT_NULL_UNDEFINED;&#10;  &#125; &#10;  if (typeof value === &#39;object&#39; || typeof value === &#39;function&#39;) &#123;&#10;    return WEIGHT_OBJECT_FUNCTION;&#10;  &#125;&#10;  return WEIGHT_PRIMITIVE;&#10;&#125;&#10;function getMapValues(map) &#123;  &#10;  return [...map.values()];&#10;&#125;&#10;function getPlainObjectValues(object) &#123;  &#10;  return Object.keys(object).map(function (key) &#123;&#10;    return object[key];&#10;  &#125;);&#10;&#125;&#10;function getCollectionValues(collection) &#123;  &#10;  if (collection instanceof Array) &#123;&#10;    return collection;&#10;  &#125;&#10;  if (collection instanceof Map) &#123;&#10;    return getMapValues(collection);&#10;  &#125;&#10;  return getPlainObjectValues(collection);&#10;&#125;&#10;function reduceWeightSum(sum, item) &#123;  &#10;  return sum + getWeightByType(item);&#10;&#125;&#10;function getCollectionWeight(collection) &#123;  &#10;  return getCollectionValues(collection).reduce(reduceWeightSum, 0);&#10;&#125;&#10;let myArray = [null, &#123; &#125;, 15];  &#10;let myMap = new Map([ [&#39;functionKey&#39;, function() &#123;&#125;] ]);  &#10;let myObject = &#123; &#39;stringKey&#39;: &#39;Hello world&#39; &#125;;  &#10;getCollectionWeight(myArray);  // =&#62; 7 (1 + 4 + 2)  &#10;getCollectionWeight(myMap);    // =&#62; 4  &#10;getCollectionWeight(myObject); // =&#62; 2</span><br></pre></td></tr></table></figure></p>
<p>That's the art of writing small and plain functions!</p>
<p>After all these code quality optimizations, you get a bunch of nice benefits:</p>
<ul>
<li>*The readability of getCollectionWeight() increased by self-explanatory code</li>
<li>*The size of getCollectionWeight() reduced considerable</li>
<li>*getCollectionWeight() function is now protected from fast growth if you plan to implement the weight calculation of other collection types</li>
<li>*The extracted functions are now decoupled and reusable components. Your colleague may ask you to import these nice functions into another project: and you can easily do that</li>
<li>*If accidentally a function generates an error, the call stack will be more precise because it contains the function names. Almost instantly you could determine the function that makes problems</li>
<li>*The split functions are much easier to test and reach a high level of code coverage. Instead of testing one big function with all possible scenarios, you can structure your tests and verify each small function separately</li>
<li>*You can benefit from CommonJS or ES2015 modules format. Create from extracted functions separated modules. This makes your project files lightweight and structured.
These advantages help you survive in the complexity of the applications.</li>
</ul>
<p><img src="/images/post/20160922/2.png" alt="2"></p>
<p>As a general rule, your functions should not be longer than 20 lines of code. Smaller - better.</p>
<p>I think now you want to ask me a reasonable question: &quot;I don't want to create functions for each line of code. Is there a criteria when I should stop splitting?&quot; This is a subject of the next chapter.</p>
<h1>2. Functions should be plain</h1>
<p>Let's relax a bit and think what is actually a software application?</p>
<p>Every application is implementing a list of requirements. The role of developer is to divide these requirements into small executable components (namespaces, classes, functions, code blocks) that do a well determined task.</p>
<p>A component consists of other smaller components. If you want to code a component, you need to create it from components at only one level down in abstraction.</p>
<p>In other words, what you need is to decompose a function into smaller steps, but keep these steps at the same, one step down, level of abstraction. This is important because it makes the function plain and implies to &quot;do one thing and do it well&quot;.</p>
<p>Why is this necessary? Because plain functions are obvious. Obvious means easy to read and modify.</p>
<p>Let's follow an example. Suppose you want to implement a function that keeps only prime numbers (2, 3, 5, 7, 11, etc) in an array, removing non prime ones (1, 4, 6, 8, etc). The function is invoked this way:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getOnlyPrime([2, 3, 4, 5, 6, 8, 11]); // =&#62; [2, 3, 5, 11]</span><br></pre></td></tr></table></figure></p>
<p>What are steps at one level down in abstraction to implement the function getOnlyPrime()? Let's formulate this way:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To implement getOnlyPrime() function, filter the array of numbers using isPrime() function.</span><br></pre></td></tr></table></figure></p>
<p>Simply, just apply a filter function isPrime() over the array of numbers.</p>
<p>Do you need to implement the details of isPrime() at this level? No, because getOnlyPrime() function would have steps from different level of abstractions. The function would take too much responsibility.</p>
<p>Having the plain idea in mind, let's implement the body of getOnlyPrime() function:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getOnlyPrime(numbers) &#123;  &#10;  return numbers.filter(isPrime);&#10;&#125;&#10;getOnlyPrime([2, 3, 4, 5, 6, 8, 11]); // =&#62; [2, 3, 5, 11]</span><br></pre></td></tr></table></figure></p>
<p>As you can see, getOnlyPrime() is plain and simple. It contains steps from a single level of abstraction: .filter() array method and isPrime().</p>
<p>Now is the time move one level down in abstraction.</p>
<p>The array method .filter() is provided by JavaScript engine and use it as is. Of course the standard describes exactly what it does.</p>
<p>Now you can detail into how isPrime() should be implemented:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To implement isPrime() function that checks if a number n is prime, verify if any number from 2 to Math.sqrt(n) evenly divides n.</span><br></pre></td></tr></table></figure></p>
<p>Having this algorithm (yet not efficient, but used for simplicity), let's code isPrime() function:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function isPrime(number) &#123;  &#10;  if (number === 3 || number === 2) &#123;&#10;    return true;&#10;  &#125;&#10;  if (number === 1) &#123;&#10;    return false;&#10;  &#125;&#10;  for (let divisor = 2; divisor &#60;= Math.sqrt(number); divisor++) &#123;&#10;    if (number % divisor === 0) &#123;&#10;      return false;&#10;    &#125;&#10;  &#125;&#10;  return true;&#10;&#125;&#10;function getOnlyPrime(numbers) &#123;  &#10;  return numbers.filter(isPrime);&#10;&#125;&#10;getOnlyPrime([2, 3, 4, 5, 6, 8, 11]); // =&#62; [2, 3, 5, 11]</span><br></pre></td></tr></table></figure></p>
<p>getOnlyPrime() is small and plain. It has only strictly necessary steps from one level down in abstraction.</p>
<p>The readability of complex functions can be much improved if you follow the rule of making them plain. Having each level of abstraction coded precisely prevents the creation of big chunks of unmaintainable code.</p>
<h1>3. Use concise function names</h1>
<p>Function names should be concise: no more and no less. Ideally the name suggests clearly what the function does, without the necessity to dive into the implementation details.</p>
<p>For function names use camel case format that starts with a lowercase letter: addItem(), saveToStore() or getFirstName().</p>
<p>Because functions are actions, the name should contain at least one verb. For example deletePage(), verifyCredentials(). To get or set a property, use the standard set and get prefixes: getLastName() or setLastName().</p>
<p>Avoid in the production code misleading names like foo(), bar(), a(), fun(), etc. Such names have no meaning.</p>
<p>If functions are small and plain, names are concise: the code is read as a wonderful prose.</p>
<h1>4. Conclusion</h1>
<p>Certainly the provided examples are quite simple. Real world applications are more complex. You may complain that writing plain functions, with only one level down in abstraction, is a tedious task. But it's not that complicated if your practice right from the start of the project.</p>
<p>If an application already has functions with too much responsibility, you may find hard to reorganize the code. And in many cases impossible to do in a reasonable amount of time. At least start with small: extract something you can.</p>
<p>Of course the correct solution is to implement the application correctly from the start. And dedicate time not only to implementation, but also to a correct structure of your functions: as suggested make them small and plain.</p>
<p><code>Measure seven times, cut once.</code></p>
<p><img src="/images/post/20160922/HappyMac.jpg" alt="HappyMac"></p>
<p>ES2015 implements a nice module system, that clearly suggest that small functions are a good practice.</p>
<p>Just remember that clean and organized code always deserves investing time. You may find it hard to do. You may need a lot of practice. You may come back and modify a function multiple times.</p>
<p>Nothing can be worse than messy code.</p>

	</div>

	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="/2016/09/22/enlearn/The art of writing small and plain functions/" data-title="The art of writing small and plain functions" data-url="http://hardog.net/2016/09/22/enlearn/The art of writing small and plain functions/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"hardog"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</div>

<script src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js" type="text/javascript"></script>
<script src="/js/translate.js" type="text/javascript"></script>

<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-76506889-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>